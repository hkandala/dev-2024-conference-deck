import { CodeSurfer } from "code-surfer";
import { vsDark } from "@code-surfer/themes";
import { Notes } from "mdx-deck";

import "prismjs/components/prism-java";

import "./styles.css";

import tweet from "./assets/tweet.png";
import comparisonVid from "./assets/comparison.mp4";
import comparisonImg from "./assets/comparison.png";
import channels from "./assets/channels.mp4";
import graph from "./assets/graph.png";

export const theme = {
  googleFont: "https://fonts.googleapis.com/css?family=IBM+Plex+Mono",
  fonts: {
    body: '"IBM Plex Mono", monospace',
    monospace: '"IBM Plex Mono", monospace',
  },
  colors: {
    text: "#f0eeed",
    background: "#161a1e",
  },
  styles: {
    root: {
      textAlign: "left",
    },
    Slide: {
      display: "block",
    },
    h1: {
      paddingBottom: "0.5em",
      borderBottom: "10px solid",
    },
    h2: {
      paddingBottom: "0.4em",
      borderBottom: "5px solid",
    },
    h3: {
      paddingBottom: "0.3em",
      borderBottom: "5px solid",
    },
    p: {
      fontSize: "0.75em",
    },
    li: {
      fontSize: "0.75em",
    },
  },
};

<div className="title-slide">

# Concurrency Models Demystified

Harish Kandala

</div>

---

<div className="content-slide">

### About Me

Harish Kandala

Enterprise Engineer @ Meta

TODO

</div>

---

<div className="image-slide">
  <Image className="image" src={tweet}></Image>
</div>

---

<div className="content-slide">

### Why Concurrency?

- The clock speed, the metronome of processors, steadily increased until peaking at 3.7 GHz in 2004. Since then, it has dropped back to around 3 GHz.
- The number of transistors on a chip has continued to double every two years, but the power consumption has also doubled.
- The primary goal of using conccurent programming is to make the most of the available resources.

<br />

</div>

---

<div className="image-slide" style={{ backgroundColor: "white" }}>
  <Image className="image" src={graph}></Image>
</div>

---

<div className="quote-slide">
<div>

> "The Free Lunch Is Over"

<div className="reference">- Herb Sutter</div>

</div>
</div>

---

<div className="content-slide">

### What is Concurrency?

- The dictionary defines concurrency as... <br/> "simultaneous occurrence"
- Different names like thread, task, or process refer to simultaneous occurrences, all representing a sequence of instructions running in order.
- It involves breaking down tasks into smaller, independent units that can be executed out-of-order or in partial order, without affecting the final outcome.

<Notes>
  <div className="notes">lorem ipsum dolor sit amet</div>
</Notes>

</div>

---

<div className="content-slide">

### Concurrency vs Parallelism

As Rob Pike puts it, concurrency is about dealing with lots of things at once while parallelism is about doing lots of things at once.

- Concurrency: It's a way to structure a program to handle multiple tasks that could be independent or interdependent.
- Parallelism: It involves performing multiple operations simultaneously, typically using multiple processors or cores.

</div>

---

<div className="center-slide">

<video width="1600" height="900" autoPlay loop>
  <source src={comparisonVid} type="video/mp4" />
  Your browser does not support the video tag.
</video>

</div>

---

<div className="image-slide" style={{ backgroundColor: "white" }}>
  <Image className="image" src={comparisonImg}></Image>
</div>

---

<div className="content-slide">

### What is Concurrency Model?

- A concurrency model is a way of structuring the code to make it easier to write and reason about concurrent programs.
- It is a way of thinking about concurrency.
- Concurrency models should be easy to use, understand, and reason about.
- They are broadly classified into three categories:

  - shared state
  - message passing
  - asynchronous programming.

</div>

---

<div className="content-slide">

### Shared Mutable State

Shared mutable state works as follows:

- If two or more parties can change the same data (variables, objects, etc.).
- And if their lifetimes overlap.
- Then there is a risk of one party's modifications preventing other parties from working correctly.

Shared mutable state is the root of all evil in concurrent programming. It is the cause of most concurrency bugs and performance issues.

</div>

---

<CodeSurfer theme={vsDark}>

```java
public class Account {
  private int id;
  private int balance;

  public Account(int id, int balance) {
    this.id = id;
    this.balance = balance;
  }

  public void deposit(int amount) {
    balance += amount;
  }

  public void withdraw(int amount) {
    if (balance >= amount) {
      balance -= amount;
    }
  }

  public int getAccountID() {
    return id;
  }

  public int getBalance() {
    return balance;
  }
}
```

```diff 10:12

```

```diff 14:18

```

</CodeSurfer>

---

<div className="center-slide">

<div>

### Locks and Synchronization

(a.k.a let's find a workaround to handle shared state)

</div>

</div>

---

<div class="content-slide">

### What and How?

- Locks are a way to prevent multiple threads from accessing shared state at the same time.
- Synchronization is a way to ensure that only one thread can access shared state at a time.
- Locks and synchronization are the most common way to handle shared state.

</div>

---

<div class="content-slide">

### Word Frequency Counter

TODO

</div>

---

<div class="content-slide">

### Pros

- Familiarity
- Control
- Performance
- Flexibility

</div>

---

<div class="content-slide">

### Cons

- Complexity
- Scalability
- Debugging Difficulty
- Portability

</div>

---

<div className="center-slide">

<div>

### Actor Model

(a.k.a what if there is no shared state at all?)

</div>

</div>

---

<div class="content-slide">

### What and How?

- The actor model is a way to structure a program to handle multiple tasks that could be independent or interdependent.
- It is based on the idea of actors, which are independent entities that communicate with each other by sending messages.
- Actors are the fundamental unit of computation in the actor model.
- The actor model is a message passing model.

</div>

---

<div class="content-slide">

### Pros

- Simplicity
- Scalability
- Isolation
- Fault Tolerance
- Asynchronous Communication

</div>

---

<div class="content-slide">

### Cons

- Overhead
- Complexity in State Management
- Learning Curve
- Debugging Difficulty
- Limited Control

</div>

---

<div className="center-slide">

<div>

### Communicating Sequential Processes

(a.k.a yet another message passing model)

</div>

</div>

---

<div class="content-slide">

### What and How?

- Communicating Sequential Processes (CSP) is a way to structure a program to handle multiple tasks that could be independent or interdependent.
- It is based on the idea of channels, which are independent entities that communicate with each other by sending messages.
- Channels are the fundamental unit of computation in the CSP model.
- The CSP model is a message passing model.

</div>

---

<div className="center-slide">

<video width="1600" height="900" autoPlay>
  <source src={channels} type="video/mp4" />
  Your browser does not support the video tag.
</video>

</div>

---

<div class="content-slide">

### Pros

- Simplicity in Concurrency
- Deadlock Avoidance
- Scalability
- Composability
- Synchronous and Asynchronous Communication

</div>

---

<div class="content-slide">

### Cons

- Performance Overhead
- Complexity in Debugging
- Learning Curve
- Potential for Bottlenecks
- Limited by Language Support

</div>

---

<div className="center-slide">

<div>

### Asynchronous Programming

(a.k.a what if we do everything in a single thread?)

</div>

</div>

---

<div class="content-slide">

### What and How?

- Asynchronous programming is a way to structure a program to handle multiple tasks that could be independent or interdependent.
- It is based on the idea of non-blocking I/O, which allows a single thread to handle multiple tasks.
- Asynchronous programming is a way to handle concurrency without using multiple threads.

</div>

---

<div class="content-slide">

### Pros

- Non-blocking I/O
- Simpler Asynchronous Code
- Improved Performance
- Concurrency Management
- Error Handling

</div>

---

<div class="content-slide">

### Cons

- Potential for Complexity
- Learning Curve
- Callback Hell
- Overhead
- Error Propagation

</div>

---

<div className="content-slide">

### Which model to use?

- There is no one-size-fits-all solution.
- The choice of concurrency model depends on the problem at hand.
- Shared state is the most common model, but it is also the most error-prone.
- Message passing is a safer alternative, but it can be more complex.
- Asynchronous programming is a good fit for I/O-bound tasks.

</div>

---

<div className="content-slide">

### References

TODO

</div>
