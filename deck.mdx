import { CodeSurfer } from "code-surfer";
import { vsDark } from "@code-surfer/themes";
import { Notes } from "mdx-deck";

import "prismjs/components/prism-java";
import "prismjs/components/prism-go";

import "./styles.css";

import tweet from "./assets/tweet.png";
import comparisonImg from "./assets/comparison.png";
import channels from "./assets/channels.mp4";
import graph from "./assets/graph.png";
import locksMeme from "./assets/locks_meme.jpg";
import asyncMeme from "./assets/async_meme.jpg";

export const theme = {
  googleFont: "https://fonts.googleapis.com/css?family=IBM+Plex+Mono",
  fonts: {
    body: '"IBM Plex Mono", monospace',
    monospace: '"IBM Plex Mono", monospace',
  },
  colors: {
    text: "#f0eeed",
    background: "#161a1e",
  },
  styles: {
    root: {
      textAlign: "left",
    },
    Slide: {
      display: "block",
    },
    h1: {
      paddingBottom: "0.5em",
      borderBottom: "10px solid",
    },
    h2: {
      paddingBottom: "0.4em",
      borderBottom: "5px solid",
    },
    h3: {
      paddingBottom: "0.3em",
      borderBottom: "5px solid",
    },
    p: {
      fontSize: "0.75em",
    },
    li: {
      fontSize: "0.75em",
    },
  },
};

<div className="title-slide">

# Concurrency Models Demystified

Harish Kandala

</div>

<Notes>
  <div className="notes">
    <p>Alright, let's get started!</p>
    <p>Hey everyone, I am Harish Kandala.</p>
    <p>
      In the next 20 minutes, we will go over different concurrency models and
      try to get a high level understanding of it.
    </p>
    <p>
      We will first go over the question of why concurrency exists in the first
      place and why do we have so many concurrency models.
    </p>
    <p>
      Then, we'll take a practical problem which can be solved concurrently and
      we will implement solution for it in different concurrency models.
    </p>
    <p>
      Finally, we will also discuss the biggest question of all - which
      concurrency model to use?
    </p>
    <p>Before diving deeper, a short introduction about me.</p>
    <p>I work as an Enterprise Engineer at Meta in Amsterdam.</p>
    <p>
      I see sometimes people getting confused what Enterprise Engineering really
      is.
    </p>
    <p>Let me try to give a quick one liner intro.</p>
    <p>
      Enterprise Engineering at Meta focuses on building internal tools. We aim
      to improve the speed and efficiency of metamates by building the right
      tools at the right time.
    </p>
    <p>I hope that clarifies.</p>
    <p>Let's jump into the topic.</p>
  </div>
</Notes>

---

<div className="image-slide">
  <Image className="image" src={tweet} />
</div>

<Notes>
  <div className="notes">
    <p>I have come across this tweet some time ago.</p>
    <p>
      I love this because it summarises the essence of concurrency in a single
      line.
    </p>
    <p>
      And this also demonstrates why we ended up building so many different
      concurrency models in the first place, right.
    </p>
    <p>
      Fundamentally, concurrency is a hard problem to solve and each model we
      have come up with is an attempt to solve this problem in a different way.
    </p>
    <p>
      So, let's ask our first question, why concurrency exists in the first
      place.
    </p>
  </div>
</Notes>

---

<div className="content-slide">

### Why Concurrency?

- The clock speed, the metronome of processors, steadily increased until peaking at 3.7 GHz in 2004.
- The number of transistors on a chip has continued to double every two years, but the power consumption has also doubled.
- The primary goal of using concurrent programming is to make the most of the available resources.

</div>

<Notes>
  <div className="notes">
    <p>This dates back to about 20 years ago</p>
    <p>We all know about Moore's Law, right?</p>
    <p>
      Moore's law states that the number of transistors on a chip doubles every
      two years
    </p>
    <p>
      Even though we were able to increase the number of transistors, we hit the
      clock speed wall around early 2000s
    </p>
    <p>Have you ever wondered why we don't have 10 GHz processors today?</p>
    <p>
      We have achievd 3 GHz in mainstream processors in 2004-05 itself but the
      latest Apple M2 chip still caps around 3.49 GHz.
    </p>
  </div>
</Notes>

---

<div className="image-slide" style={{ backgroundColor: "white" }}>
  <Image className="image" src={graph} />
</div>

<Notes>
  <div className="notes">
    <p>
      Well, long story short, what happened is, with the increase in number of
      transistors, the power consumption also doubled, which increased the heat
      generated and we hit a wall.
    </p>
    <p>
      If you look at this graph, you can see that the clock speed and power has
      plateued around 2004-2005.
    </p>
    <p>
      We had to find a way to make the most of the available resources and
      that's where all these concurrency models come into play.
    </p>
  </div>
</Notes>

---

<div className="quote-slide">
<div>

"The Free Lunch Is Over"

<div className="reference">- Herb Sutter</div>

</div>
</div>

<Notes>
  <div className="notes">
    <p>
      As Herb Sutter famously puts it in his blog post, "The Free Lunch Is
      Over", we have got performance gains for free for a long time, but that's
      not the case anymore.
    </p>
    <p>
      An important note here, I don't mean we didn't have concurrency before
      2004, but the need for concurrency became more prominent after that.
    </p>
  </div>
</Notes>

---

<div className="content-slide">

### What is Concurrency?

- Concurrency is about composing and coordinating independently executing processes.
- It is a way to structure a program to handle multiple tasks that could be independent or interdependent.
- Different names like thread, task, or process refer to the "independently executing process", all representing a sequence of instructions running in order.

<Notes>
  <div className="notes">
    <p>That's a bit of short history class there</p>
    <p>
      Now, let me give a quick primer on what concurrency is and how it is
      different from being parallel
    </p>
    <p>
      If you look at the dictionary definition of concurrency, it says
      "simultaneous occurrence"
    </p>
    <p>
      But when you use the word "concurrently" in a sentence, it usually means
      something like "at the same time"
    </p>
    <p>
      But there is a subtle difference between "at the same time" and
      "simultaneous occurrence" which usually gets lost to when we refer
      something as concurrent.
    </p>
    <p>
      So, let's put it formally, Concurrency is about composing and coordinating
      independently executing processes.
    </p>
    <p>
      When I say "independently executing process" here, I mean it can be
      anything, be it thread, process, or task. All of them represent a sequence
      of instructions running in an order.
    </p>
    <p>
      Let's say you have a problem to solve and concurrency provides a way to
      structure a solution that may be parallelizable but not necessarily.
    </p>
  </div>
</Notes>

</div>

---

<div className="content-slide">

### Concurrency vs Parallelism

As Rob Pike puts it:

- Concurrency is about dealing with lots of things at once.
- Parallelism is about doing lots of things at once.
- Concurrency is about structure, parallelism is about execution.

</div>

<Notes>
  <div className="notes">
    <p>
      All the definitions I am using here are from the Rob Pike's amazing talk
      titled "Concurrency Is Not Parallelism".
    </p>
    <p>I strongly recommend you to watch that talk if you haven't already.</p>
    <p>
      So, as Rob Pike puts it: Concurrency is about dealing with lots of things
      at once where as paralleism is about doing lot of things at once.
    </p>
    <p>
      Concurrency is all about structure where as parallelism is all about
      execution.
    </p>
  </div>
</Notes>

---

<div className="image-slide" style={{ backgroundColor: "white" }}>
  <Image className="image" src={comparisonImg} />
</div>

<Notes>
  <div className="notes">
    <p>
      Let's take a look at a practical example to understand the difference.
    </p>
    <p>
      Most of the modern web servers are designed to handle multiple requests
      concurrently. Agree?
    </p>
    <p>
      Let's say we have a web server implemented in Node.js which is single
      threaded.
    </p>
    <p>
      At any point of time, Node.js process would be running only on a single
      CPU core because it is single threaded.
    </p>
    <p>
      But it can handle multiple requests concurrently because of the way it is
      structured to handle non-blocking I/O.
    </p>
    <p>
      Here, we are not executing multiple requests at the same time, but we are
      dealing with multiple requests at the same time.
    </p>
    <p>
      And on the other hand, we can also run multiple Node.js processes on
      multiple CPU cores to handle multiple requests in parallel.
    </p>
    <p>
      This is what when I mean concurrent programs can be parallelized but not
      necessarily.
    </p>
    <p>
      Again, I strongly recommend you to watch Rob Pike's talk to deep dive into
      this.
    </p>
  </div>
</Notes>

---

<div className="content-slide">

### What is Concurrency Model?

- It is a way of thinking about concurrency.
- Concurrency models should be easy to use, understand, and reason about.
- They are broadly classified into three categories:

  - shared memory
  - message passing
  - asynchronous programming.

</div>

<Notes>
  <div className="notes">
    <p>
      So, I hope I made it clear by now that concurrency is all about structure
      and coordination.
    </p>
    <p>And we can structure and coordinate in different ways right.</p>
    <p>
      Each concurrency model sets the ground rules and provides us tools on how
      we can structure our program and do any coordination if needed.
    </p>
    <p>
      To simply put, a concurrency model is just a way of thinking about
      concurrency.
    </p>
    <p>It should be easy to use, understand, and reason about.</p>
    <p>
      And, all of these different models are all about how we handle this thing
      called shared mutable state.
    </p>
    <p>Shared mutable is the root of all evil.</p>
    <p>
      We can group these concurrency models broadly intro three categories based
      on how they handle this evil: shared mutable state.
    </p>
    <p>Keep in mind that there are more but these are the most common ones.</p>
  </div>
</Notes>

---

<div className="center-slide">

<div>

### Shared Memory Synchronization

(a.k.a let's find a workaround to handle shared state)

</div>

</div>

<Notes>
  <div className="notes">
    <p>Okay, let's start with the first one, shared memory synchronization.</p>
    <p>
      I mean the terminology used might seem bit strange but I am sure you all
      are familiar with semaphore or locks, right?
    </p>
    <p>
      Here, we are accepting the fact that we have shared mutable state and we
      are trying to use some tools or I would say a workaround to handle them.
    </p>
  </div>
</Notes>

---

<div class="content-slide">

### What and How?

- A synchronization primitive is any structure that attempts to control the order of your code and prevent race conditions.
- The most simple synchronization primitive is known as the lock, but there are many others like semaphores, monitors, etc.
- These synchronization primitives are of two types: blocking and non-blocking.

</div>

<Notes>
  <div className="notes">
    <p>
      Because we have shared mutable state, multiple threads can access this
      shared state at the same time and that's not actually good as we might end
      up in race conditions.
    </p>
    <p>
      Anyone who worked on concurrent systems would tell you that race
      conditions are the worst to debug and fix.
    </p>
    <p>
      So to avoid these race conditions we need to synchronize this shared
      memory access, ensuring that only one thread can access it at a time.
    </p>
    <p>
      Well, we can achieve that using these synchronization primitives like
      locks, semaphores, or monitors controlling access to critical sections.
    </p>
    <p>
      I won't go into the details of these as I assume most of you are familiar
      with them already.
    </p>
    <p>
      And these synchronization primitives can be categorized into two types:
      blocking and non-blocking.
    </p>
    <p>
      Note that this blocking and non-blocking not just applies to
      synchronization primitives but also to any concurrency algorithm, I bet
      you might have heard of these terms in the context of I/O operations as
      well like blocking I/O and non-blocking I/O.
    </p>
    <p>
      In general, we can categorize any concurrency algorithm into blocking and
      non-blocking.
    </p>
    <p>
      A blocking concurrency algorithm is basically either performs the action
      requested by the thread or blocks the thread until the action can be
      performed safely.
    </p>
    <p>
      Where as a non-blocking concurrency algorithm either performs the action
      requested by the thread or notifies the requesting thread that the action
      could not be performed
    </p>
    <p>
      So the difference is in how they handle the situation when the action
      can't be performed immediately.
    </p>
    <p>
      In the context of synchronization primitives locks, mutexes, and
      semaphores are all examples of blocking concurrency algorithms.
    </p>
    <p>
      Atomic operations like AtomicInteger or AtomicBoolean in Java or any other
      lock-free data structures are examples of non-blocking concurrency
      algorithms.
    </p>
  </div>
</Notes>

---

<div class="content-slide">

### What is the most used word in all session abstracts of this conference?

- Identify the most used word in conference session abstracts, utilizing a custom node.js server API for data retrieval.
- Extract all the session abstacts by making 135 requests to the API, tokenize them, and count the words.
- Note that this is just for demonstration and concurrency is complete overkill for this problem.

</div>

<Notes>
  <div className="notes">
    <p>
      Most of you would be already feeling like: "this is too much theory, show
      me some code man".
    </p>
    <p>I hear you guys, let's take a practical problem and solve it.</p>
    <p>
      I spent a lot of time in figuring out which would be a good example to
      demonstrate, I hope this one is good.
    </p>
    <p>
      So, the problem is simple - I want to know the most used word in all
      session abstracts of this conference.
    </p>
    <p>
      All of you would have already visited devworldconference.com and if you go
      to program page, you can see all the session abstracts.
    </p>
    <p>
      A simple reverse engineering led me to an API which has all the session
      abstracts.
    </p>
    <p>
      But I am a responsible developer and I don't want to bombard their server
      with too many requests.
    </p>
    <p>
      So, I copied the data and created a simple node.js server where given an
      id of a session, it returns the abstract.
    </p>
    <p>
      Alright, so now we have an API where given an id of a session, it returns
      the abstract, and there are 135 sessions in total.
    </p>
    <p>
      All we need to do is call this API 135 times, get the abstracts, tokenize
      them, and count the words. Simple right?
    </p>
    <p>
      And note that I understand that this is a very simple problem, we can
      solve it in a single thread as well and concurrency is complete overkill,
      but for the sake of demonstration, let's solve it concurrently.
    </p>
  </div>
</Notes>

---

<CodeSurfer theme={vsDark}>

```java
public class Main {

  public static void main(String[] args) {
    final HttpClient client = HttpClient.newHttpClient();

    List<String> urls = getURLs();

    final List<String> responses = new ArrayList<>();
    final Map<String, Integer> wordCount = new HashMap<>();

    // Fetch each URL content sequentially and store in responses list
    urls.forEach(url -> {
      HttpRequest request = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .GET()
          .build();
      try {
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        responses.add(response.body());
      } catch (IOException | InterruptedException e) {
        e.printStackTrace();
      }
    });

    // Loop through each response, tokenize and populate the word count map
    responses.forEach(response -> {
      StringTokenizer tokenizer = new StringTokenizer(response);
      while (tokenizer.hasMoreTokens()) {
        String word = tokenizer.nextToken().toLowerCase();
        wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
      }
    });

    printMostUsedWords(wordCount);
  }
}
```

```diff 11:23

```

```diff 25:32

```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```java
public class Main {

  private static final int NUM_PRODUCERS = 20;
  private static final int NUM_CONSUMERS = 20;

  private static final BlockingQueue<String> responseQueue = new LinkedBlockingQueue<>();

  private static final Map<String, Integer> wordCount = new HashMap<>();

  public static void main(String[] args) {
    final HttpClient client = HttpClient.newHttpClient();

    List<String> urls = getURLs();

    ExecutorService producerService = Executors.newFixedThreadPool(NUM_PRODUCERS);
    ExecutorService consumerService = Executors.newFixedThreadPool(NUM_CONSUMERS);

    // Producer Threads
    urls.forEach(url -> producerService.submit(() -> {
      HttpRequest request = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .GET()
          .build();
      try {
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        responseQueue.put(response.body());
      } catch (IOException | InterruptedException e) {
        e.printStackTrace();
      }
    }));

    // Consumer Threads
    for (int i = 0; i < NUM_CONSUMERS; i++) {
      consumerService.submit(() -> {
        try {
          while (true) {
            String response = responseQueue.take();
            StringTokenizer tokenizer = new StringTokenizer(response);
            while (tokenizer.hasMoreTokens()) {
              String word = tokenizer.nextToken().toLowerCase();
              wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
            }
          }
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      });
    }

    shutdownAndAwaitTermination(producerService);
    shutdownAndAwaitTermination(consumerService);

    printMostUsedWords(wordCount);
  }
}
```

```diff 15:16

```

```diff 18:30

```

```diff 32:48

```

```java
public class Main {

  private static final int NUM_PRODUCERS = 20;
  private static final int NUM_CONSUMERS = 20;

  private static final BlockingQueue<String> responseQueue = new LinkedBlockingQueue<>();
  private static final Lock lock = new ReentrantLock();

  private static final Map<String, Integer> wordCount = new HashMap<>();

  public static void main(String[] args) {
    final HttpClient client = HttpClient.newHttpClient();

    List<String> urls = getURLs();

    ExecutorService producerService = Executors.newFixedThreadPool(NUM_PRODUCERS);
    ExecutorService consumerService = Executors.newFixedThreadPool(NUM_CONSUMERS);

    // Producer Threads
    urls.forEach(url -> producerService.submit(() -> {
      HttpRequest request = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .GET()
          .build();
      try {
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        responseQueue.put(response.body());
      } catch (IOException | InterruptedException e) {
        e.printStackTrace();
      }
    }));

    // Consumer Threads
    for (int i = 0; i < NUM_CONSUMERS; i++) {
      consumerService.submit(() -> {
        try {
          while (true) {
            String response = responseQueue.take();
            StringTokenizer tokenizer = new StringTokenizer(response);
            while (tokenizer.hasMoreTokens()) {
              String word = tokenizer.nextToken().toLowerCase();
              wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
            }
          }
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      });
    }

    shutdownAndAwaitTermination(producerService);
    shutdownAndAwaitTermination(consumerService);

    printMostUsedWords(wordCount);
  }
}
```

```java
public class Main {

  private static final int NUM_PRODUCERS = 20;
  private static final int NUM_CONSUMERS = 20;

  private static final BlockingQueue<String> responseQueue = new LinkedBlockingQueue<>();
  private static final Lock lock = new ReentrantLock();

  private static final Map<String, Integer> wordCount = new HashMap<>();

  public static void main(String[] args) {
    final HttpClient client = HttpClient.newHttpClient();

    List<String> urls = getURLs();

    ExecutorService producerService = Executors.newFixedThreadPool(NUM_PRODUCERS);
    ExecutorService consumerService = Executors.newFixedThreadPool(NUM_CONSUMERS);

    // Producer Threads
    urls.forEach(url -> producerService.submit(() -> {
      HttpRequest request = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .GET()
          .build();
      try {
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        responseQueue.put(response.body());
      } catch (IOException | InterruptedException e) {
        e.printStackTrace();
      }
    }));

    // Consumer Threads
    for (int i = 0; i < NUM_CONSUMERS; i++) {
      consumerService.submit(() -> {
        try {
          while (true) {
            String response = responseQueue.take();
            StringTokenizer tokenizer = new StringTokenizer(response);
            while (tokenizer.hasMoreTokens()) {
              String word = tokenizer.nextToken().toLowerCase();
              lock.lock();
              try {
                wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
              } finally {
                lock.unlock();
              }
            }
          }
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      });
    }

    shutdownAndAwaitTermination(producerService);
    shutdownAndAwaitTermination(consumerService);

    printMostUsedWords(wordCount);
  }
}
```

```java 41:43
public class Main {

  private static final int NUM_PRODUCERS = 20;
  private static final int NUM_CONSUMERS = 20;

  private static final BlockingQueue<String> responseQueue = new LinkedBlockingQueue<>();

  private static final Map<String, Integer> wordCount = new HashMap<>();

  public static void main(String[] args) {
    final HttpClient client = HttpClient.newHttpClient();

    List<String> urls = getURLs();

    ExecutorService producerService = Executors.newFixedThreadPool(NUM_PRODUCERS);
    ExecutorService consumerService = Executors.newFixedThreadPool(NUM_CONSUMERS);

    // Producer Threads
    urls.forEach(url -> producerService.submit(() -> {
      HttpRequest request = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .GET()
          .build();
      try {
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        responseQueue.put(response.body());
      } catch (IOException | InterruptedException e) {
        e.printStackTrace();
      }
    }));

    // Consumer Threads
    for (int i = 0; i < NUM_CONSUMERS; i++) {
      consumerService.submit(() -> {
        try {
          while (true) {
            String response = responseQueue.take();
            StringTokenizer tokenizer = new StringTokenizer(response);
            while (tokenizer.hasMoreTokens()) {
              String word = tokenizer.nextToken().toLowerCase();
              synchronized (wordCount) {
                wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
              }
            }
          }
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      });
    }

    shutdownAndAwaitTermination(producerService);
    shutdownAndAwaitTermination(consumerService);

    printMostUsedWords(wordCount);
  }
}
```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```java
public class AccountManager {
    public static void transferMoney(Account from, Account to, int amount)
        throws InsufficientBalanceException {
        if (from.getBalance() < amount)
            throw new InsufficientBalanceException(...);
        from.debit(amount);
        to.credit(amount);
    }
}
```

```java 4:9
public class AccountManager {
    public static void transferMoney(Account from, Account to, int amount)
        throws InsufficientBalanceException {
        // Unsafe check-then-act
        if (from.getBalance() < amount)
            throw new InsufficientBalanceException(...);
        from.debit(amount);
        to.credit(amount);
    }
}
```

```java
public class AccountManager {
    public static void transferMoney(Account from, Account to, int amount)
        throws InsufficientBalanceException {
        synchronized(from) {
            synchronized(to) {
                if (from.getBalance() < amount)
                    throw new InsufficientBalanceException(...);
                from.debit(amount);
                to.credit(amount);
            }
        }
    }
}
```

```java 4:12
public class AccountManager {
    public static void transferMoney(Account from, Account to, int amount)
        throws InsufficientBalanceException {
        // Synchronize on both accounts
        synchronized(from) {
            synchronized(to) {
                if (from.getBalance() < amount)
                    throw new InsufficientBalanceException(...);
                from.debit(amount);
                to.credit(amount);
            }
        }
    }
}
```

```java 4:13
public class AccountManager {
    public static void transferMoney(Account from, Account to, int amount)
        throws InsufficientBalanceException {
        // However, this can lead to deadlock
        // Synchronize on both accounts
        synchronized(from) {
            synchronized(to) {
                if (from.getBalance() < amount)
                    throw new InsufficientBalanceException(...);
                from.debit(amount);
                to.credit(amount);
            }
        }
    }
}
```

```java 4:12
public class AccountManager {
    public static void transferMoney(Account from, Account to, int amount)
        throws InsufficientBalanceException {
        // Ensure lock ordering to avoid deadlock
        Account first, second;
        if (from.getAccountNumber() < to.getAccountNumber()) {
            first = from;
            second = to;
        } else {
            first = to;
            second = from;
        }

        // Synchronize on both accounts
        synchronized(from) {
            synchronized(to) {
                if (from.getBalance() < amount)
                    throw new InsufficientBalanceException(...);
                from.debit(amount);
                to.credit(amount);
            }
        }
    }
}
```

```diff

```

</CodeSurfer>

---

<div class="content-slide">

### Pros

- Familiarity
- Control
- Performance
- Flexibility

</div>

---

<div class="content-slide">

### Cons

- Complexity
- Scalability
- Debugging Difficulty
- Portability

</div>

---

<div className="image-slide">
  <Image className="image" src={locksMeme} />
</div>

---

<div className="center-slide">

<div>

### Actor Model

(a.k.a what if there is no shared state at all?)

</div>

</div>

---

<div class="content-slide">

### What and How?

- The actor model is a way to structure a program to handle multiple tasks that could be independent or interdependent.
- It is based on the idea of actors, which are independent entities that communicate with each other by sending messages.
- Actors are the fundamental unit of computation in the actor model.
- The actor model is a message passing model.

</div>

---

<CodeSurfer theme={vsDark}>

```java
public class URLFetcherActor extends AbstractActor {
  static class Fetch {
    public final String url;
    public final ActorRef counterRef;

    public Fetch(String url, ActorRef counterRef) {
      this.url = url;
      this.counterRef = counterRef;
    }
  }

  private final HttpClient client = HttpClient.newHttpClient();

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(Fetch.class, this::onFetch)
        .build();
  }

  private void onFetch(Fetch message) {
    try {
      HttpRequest request = HttpRequest.newBuilder()
          .uri(URI.create(message.url))
          .GET()
          .build();
      HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
      message.counterRef.tell(new WordCounterActor.CountWords(response.body(), getSender()), getSelf());
    } catch (IOException | InterruptedException e) {
      e.printStackTrace();
    }
  }
}
```

```diff 14:19

```

```diff 21:32

```

```diff 28

```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```java
public class WordCounterActor extends AbstractActor {
  static class CountWords {
    public final String content;
    public final ActorRef orchestratorRef;

    public CountWords(String content, ActorRef orchestratorRef) {
      this.content = content;
      this.orchestratorRef = orchestratorRef;
    }
  }

  static class PrintResults {
  }

  static class ProcessComplete {
  }

  private final Map<String, Integer> wordCount = new HashMap<>();

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(CountWords.class, this::onCountWords)
        .match(PrintResults.class, this::onPrintResults)
        .build();
  }

  private void onCountWords(CountWords message) {
    StringTokenizer tokenizer = new StringTokenizer(message.content);
    while (tokenizer.hasMoreTokens()) {
      String word = tokenizer.nextToken().toLowerCase();
      wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
    }
    message.orchestratorRef.tell(new ProcessComplete(), getSelf());
  }
}
```

```diff 20:26

```

```diff 28:35

```

```diff 34

```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```java
public class OrchestratorActor extends AbstractActor {
  private final ActorRef wordCounterActor;
  private final List<ActorRef> fetcherActors = new ArrayList<>();

  private final int totalURLs;
  private int completed = 0;

  public OrchestratorActor() {
    List<String> urls = getURLs();
    totalURLs = urls.size();

    wordCounterActor = getContext().actorOf(Props.create(WordCounterActor.class), "wordCounter");

    urls.forEach(url -> {
      ActorRef fetcher = getContext().actorOf(Props.create(URLFetcherActor.class));
      fetcherActors.add(fetcher);
      fetcher.tell(new URLFetcherActor.Fetch(url, wordCounterActor), getSelf());
    });
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(WordCounterActor.ProcessComplete.class, this::onProcessComplete)
        .build();
  }

  private void onProcessComplete(WordCounterActor.ProcessComplete message) {
    completed++;
    if (completed == totalURLs) {
      wordCounterActor.tell(new WordCounterActor.PrintResults(), getSelf());
    }
  }
}
```

```diff 2:3

```

```diff 8:19

```

```diff 21:26

```

```diff 28:33

```

</CodeSurfer>

---

<div class="content-slide">

### Pros

- Simplicity
- Scalability
- Isolation
- Fault Tolerance
- Asynchronous Communication

</div>

---

<div class="content-slide">

### Cons

- Overhead
- Complexity in State Management
- Learning Curve
- Debugging Difficulty
- Limited Control

</div>

---

<div className="center-slide">

<div>

### Communicating Sequential Processes

(a.k.a yet another message passing model)

</div>

</div>

---

<div class="content-slide">

### What and How?

- Communicating Sequential Processes (CSP) is a way to structure a program to handle multiple tasks that could be independent or interdependent.
- It is based on the idea of channels, which are independent entities that communicate with each other by sending messages.
- Channels are the fundamental unit of computation in the CSP model.
- The CSP model is a message passing model.

</div>

---

<CodeSurfer theme={vsDark}>

```go
func main() {
	urls := getURLs()

	responseCh := make(chan string)
	wordCountCh := make(chan map[string]int)

	var wg sync.WaitGroup

	go countWords(responseCh, wordCountCh)

	for _, url := range urls {
		wg.Add(1)
		go fetchURL(url, responseCh, &wg)
	}

	wg.Wait()

	close(responseCh)

	wordCount := <-wordCountCh

	printMostUsedWords(wordCount)
}

func fetchURL(url string, responseCh chan<- string, wg *sync.WaitGroup) {
	defer wg.Done()
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf("Failed to fetch %s: %v\n", url, err)
		return
	}
	defer resp.Body.Close()
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		responseCh <- scanner.Text()
	}
}

func countWords(responseCh <-chan string, wordCountCh chan<- map[string]int) {
	wordCount := make(map[string]int)
	for text := range responseCh {
		words := strings.Fields(text)
		for _, word := range words {
			word = strings.ToLower(word)
			wordCount[word]++
		}
	}
	wordCountCh <- wordCount
}
```

```diff 1:23

```

```diff 4:5

```

```diff 11:14

```

```diff 25:37

```

```diff 35

```

```diff 9

```

```diff 39:49

```

```diff 48

```

```diff 20

```

```diff 1:23

```

</CodeSurfer>

---

<div className="center-slide">

<video width="1600" height="900" autoPlay>
  <source src={channels} type="video/mp4" />
  Your browser does not support the video tag.
</video>

</div>

---

<div class="content-slide">

### Pros

- Simplicity in Concurrency
- Deadlock Avoidance
- Scalability
- Composability
- Synchronous and Asynchronous Communication

</div>

---

<div class="content-slide">

### Cons

- Performance Overhead
- Complexity in Debugging
- Learning Curve
- Potential for Bottlenecks
- Limited by Language Support

</div>

---

<div className="image-slide">
  <Image className="image" src={asyncMeme} />
</div>

---

<div className="center-slide">

<div>

### Asynchronous Programming

(a.k.a what if we do everything in a single thread?)

</div>

</div>

---

<div class="content-slide">

### What and How?

- Asynchronous programming is a way to structure a program to handle multiple tasks that could be independent or interdependent.
- It is based on the idea of non-blocking I/O, which allows a single thread to handle multiple tasks.
- Asynchronous programming is a way to handle concurrency without using multiple threads.

</div>

---

<CodeSurfer theme={vsDark}>

```javascript
main().catch(console.error);

async function main() {
  const urls = getURLs();
  const responses = await fetchURLContent(urls);

  const wordCount = new Map();
  responses.forEach((response) => updateWordCount(response, wordCount));

  printMostUsedWords(wordCount);
}

async function fetchURLContent(urls) {
  const fetch = (await import("node-fetch")).default;
  const fetchPromises = urls.map((url) => fetch(url).then((res) => res.text()));
  return Promise.all(fetchPromises);
}

function updateWordCount(text, wordCount) {
  const words = text.split(/[ \t\n\r\f]+/).map((word) => word.toLowerCase());
  words.forEach((word) => {
    wordCount.set(word, (wordCount.get(word) || 0) + 1);
  });
}

function printMostUsedWords(wordCount) {
  const sortedWords = Array.from(wordCount.entries())
    .filter((entry) => !IGNORED_WORDS.has(entry[0]))
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);
  sortedWords.forEach(([word, count]) => {
    console.log(`${word}: ${count}`);
  });
}
```

```diff 3:11

```

```diff 5

```

```diff 13:17

```

```diff 16

```

```diff 7:8

```

```diff 19:24

```

```diff 3:11

```

</CodeSurfer>

---

<div class="content-slide">

### Pros

- Non-blocking I/O
- Simpler Asynchronous Code
- Improved Performance
- Concurrency Management
- Error Handling

</div>

---

<div class="content-slide">

### Cons

- Potential for Complexity
- Learning Curve
- Callback Hell
- Overhead
- Error Propagation

</div>

---

<div className="content-slide">

### Which model to use?

- There is no one-size-fits-all solution.
- The choice of concurrency model depends on the problem at hand.
- Shared state is the most common model, but it is also the most error-prone.
- Message passing is a safer alternative, but it can be more complex.
- Asynchronous programming is a good fit for I/O-bound tasks.

</div>

---

<div className="content-slide">

### References

TODO

</div>
